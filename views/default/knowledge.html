<html>

    <head>
        <link rel="stylesheet" href="{{=URL('static','css/bootstrap.min.css')}}"/>
        <link rel="stylesheet" href="{{=URL('static','css/web2py-bootstrap3.css')}}"/>
        <link rel="stylesheet" href="/welcome/static/GoJS-master/assets/css/main.css">
        <!--<link rel="stylesheet" href="/welcome/static/GoJS-master/assets/css/bootstrap.min.css">-->
        <link rel="stylesheet" href="/welcome/static/GoJS-master/assets/css/highlight.css">
        <link rel="stylesheet" href="/welcome/static/GoJS-master/assets/css/jquery-ui.min.css">
    </head>

    <body>

        <!-- form: create/modify concepts -->
        <h2>Create a new concept</h2>
        {{=LOAD('default', 'concept.load', ajax=True)}}

        <!-- graph editor -->
        <h2>Build a relation with concepts</h2>
        <div id="graph-buttons" style="margin-bottom: 20px">
            <button id="graph-save-button" type="button" onclick="saveLaw()">Save Relation</button>
        </div>
        <div style="width: 100%; display: flex; justify-content: space-between">
            <div id="concept-palette" style="width: 160px; margin-right: 2px; background-color: whitesmoke; border: solid 1px black"></div>
            <div id="graph-canvas" style="flex-grow: 1; height: 620px; border: solid 1px black"></div>
        </div>

        <input type="hidden" id="current_framework" value="-1">
        <input type="hidden" id="current_law" value="-1">
    </body>



    {{block page_js}}
    {{include 'web2py_ajax.html'}}
    <script src="/welcome/static/GoJS-master/release/go.js"></script>
    <script src="/welcome/static/GoJS-master/assets/js/highlight.js"></script>
    <script src="/welcome/static/GoJS-master/assets/js/bootstrap.min.js"></script>
    <!--<script src="{{=URL('static', 'js/knowledge.js')}}"></script>-->
    <script>
        var $$ = go.GraphObject.make;

          // This variation on ForceDirectedLayout does not move any selected Nodes
          // but does move all other nodes (vertexes).
          function ContinuousForceDirectedLayout() {
            go.ForceDirectedLayout.call(this);
            this._isObserving = false;
          }
          go.Diagram.inherit(ContinuousForceDirectedLayout, go.ForceDirectedLayout);

          /** @override */
          ContinuousForceDirectedLayout.prototype.isFixed = function(v) {
            return v.node.isSelected;
          }

          // optimization: reuse the ForceDirectedNetwork rather than re-create it each time
          /** @override */
          ContinuousForceDirectedLayout.prototype.doLayout = function(coll) {
            if (!this._isObserving) {
              this._isObserving = true;
              // cacheing the network means we need to recreate it if nodes or links have been added or removed or relinked,
              // so we need to track structural model changes to discard the saved network.
              var lay = this;
              this.diagram.addModelChangedListener(function (e) {
                // modelChanges include a few cases that we don't actually care about, such as
                // "nodeCategory" or "linkToPortId", but we'll go ahead and recreate the network anyway.
                // Also clear the network when replacing the model.
                if (e.modelChange !== "" ||
                    (e.change === go.ChangedEvent.Transaction && e.propertyName === "StartingFirstTransaction")) {
                  lay.network = null;
                }
              });
            }
            var net = this.network;
            if (net === null) {  // the first time, just create the network as normal
              this.network = net = this.makeNetwork(coll);
            } else {  // but on reuse we need to update the LayoutVertex.bounds for selected nodes
              this.diagram.nodes.each(function (n) {
                var v = net.findVertex(n);
                if (v !== null) v.bounds = n.actualBounds;
              });
            }
            // now perform the normal layout
            go.ForceDirectedLayout.prototype.doLayout.call(this, coll);
            // doLayout normally discards the LayoutNetwork by setting Layout.network to null;
            // here we remember it for next time
            this.network = net;
          }
          // end ContinuousForceDirectedLayout


        var myDiagram = $$(go.Diagram, "graph-canvas",  // must name or refer to the DIV HTML element
        {
          grid: $$(go.Panel, "Grid",
                  $$(go.Shape, "LineH", { stroke: "lightgray", strokeWidth: 0.5 }),
                  $$(go.Shape, "LineH", { stroke: "gray", strokeWidth: 0.5, interval: 10 }),
                  $$(go.Shape, "LineV", { stroke: "lightgray", strokeWidth: 0.5 }),
                  $$(go.Shape, "LineV", { stroke: "gray", strokeWidth: 0.5, interval: 10 })
                ),
          allowDrop: true,  // must be true to accept drops from the Palette
          layout:
            $$(ContinuousForceDirectedLayout,  // automatically spread nodes apart while dragging
              { defaultSpringLength: 30, defaultElectricalCharge: 100 }),
          // do an extra layout at the end of a move
          "SelectionMoved": function(e) { e.diagram.layout.invalidateLayout(); },
          "draggingTool.dragsLink": true,
          "draggingTool.isGridSnapEnabled": true,
          "linkingTool.isUnconnectedLinkValid": true,
          "linkingTool.portGravity": 20,
          "relinkingTool.isUnconnectedLinkValid": true,
          "relinkingTool.portGravity": 20,
          "relinkingTool.fromHandleArchetype":
            $$(go.Shape, "Diamond", { segmentIndex: 0, cursor: "pointer", desiredSize: new go.Size(8, 8), fill: "tomato", stroke: "darkred" }),
          "relinkingTool.toHandleArchetype":
            $$(go.Shape, "Diamond", { segmentIndex: -1, cursor: "pointer", desiredSize: new go.Size(8, 8), fill: "darkred", stroke: "tomato" }),
          "linkReshapingTool.handleArchetype":
            $$(go.Shape, "Diamond", { desiredSize: new go.Size(7, 7), fill: "lightblue", stroke: "deepskyblue" }),
          //rotatingTool: $(TopRotatingTool),  // defined below
          //"rotatingTool.snapAngleMultiple": 15,
          //"rotatingTool.snapAngleEpsilon": 15,
          "undoManager.isEnabled": true
        });

        // dragging a node invalidates the Diagram.layout, causing a layout during the drag
        myDiagram.toolManager.draggingTool.doMouseMove = function() {
          go.DraggingTool.prototype.doMouseMove.call(this);
          if (this.isActive) { this.diagram.layout.invalidateLayout(); }
        }

        // when the document is modified, add a "*" to the title and enable the "Save" button
        myDiagram.addDiagramListener("Modified", function(e) {
          var button = document.getElementById("graph-save-button");
          if (button) button.disabled = !myDiagram.isModified;
          var idx = document.title.indexOf("*");
          if (myDiagram.isModified) {
            if (idx < 0) document.title += "*";
          } else {
            if (idx >= 0) document.title = document.title.substr(0, idx);
          }
        });

        myDiagram.nodeTemplate = $$(go.Node, "Spot",
            { locationSpot: go.Spot.Center },
            new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
            new go.Binding("angle").makeTwoWay(),
            // the main object is a Panel that surrounds a TextBlock with a Shape
            $$(go.Panel, "Auto",
              { name: "PANEL" },
              new go.Binding("desiredSize", "size", go.Size.parse).makeTwoWay(go.Size.stringify),
              $$(go.Shape, "Rectangle",  // default figure
                {
                  cursor: "pointer",
                  fill: "white",  // default color
                  strokeWidth: 2
                },
                new go.Binding("figure"),
                new go.Binding("fill")),
              $$(go.TextBlock,
                {
                  font: "bold 11pt Helvetica, Arial, sans-serif",
                  margin: 8,
                  maxSize: new go.Size(160, NaN),
                  wrap: go.TextBlock.WrapFit,
                  editable: true
                },
                new go.Binding("text").makeTwoWay())
            ),
            //port on top for head/reference, port on bottom for properties/referrers
            makePort("T", go.Spot.Top, true, true, 1, 1),
            makePort("B", go.Spot.Bottom, true, true),
            { // handle mouse enter/leave events to show/hide the ports
              mouseEnter: function(e, node) { showSmallPorts(node, true); },
              mouseLeave: function(e, node) { showSmallPorts(node, false); }
            }
        );

        clearDiagram();

        //concepts required by any framework
        var CORE_CONCEPTS = $$(go.GraphLinksModel, {
            nodeDataArray: [
                    {{
                        concepts = db(db.concept.framework == None).select()
                        for concept in concepts:
                    }}
                { concept: {{=concept.id}}, text: "{{=concept.name}}", figure: "RoundedRectangle", fill: "#88AD5F" },
                    {{
                        pass
                    }}
            ],
            linkDataArray: []
        });

        // initialize the Palette that is on the left side of the page
        var myPalette = $$(go.Palette, "concept-palette",  // must name or refer to the DIV HTML element
        {
            maxSelectionCount: 1,
            nodeTemplateMap: myDiagram.nodeTemplateMap,  // share the templates used by myDiagram
            model: CORE_CONCEPTS,
        });


        function makePort(name, spot, output, input, fromMax, toMax) {
            // the port is basically just a small transparent square
            var options =
            {
                fill: null,  // not seen, by default; set to a translucent gray by showSmallPorts, defined below
                stroke: null,
                desiredSize: new go.Size(7, 7),
                alignment: spot,  // align the port on the main Shape
                alignmentFocus: spot,  // just inside the Shape
                portId: name,  // declare this object to be a "port"
                fromSpot: spot, toSpot: spot,  // declare where links may connect at this port
                fromLinkable: output, toLinkable: input,  // declare whether the user may draw links to/from here
                cursor: "pointer"  // show a different cursor to indicate potential link point
            };
            if(fromMax !== undefined) options.fromMaxLinks = fromMax;
            if(toMax !== undefined) options.toMaxLinks = toMax;
            return $$(go.Shape, "Circle", options);
        }

        function showSmallPorts(node, show) {
          node.ports.each(function(port) {
            if (port.portId !== "") {  // don't change the default port, which is the big shape
              port.fill = show ? "rgba(0,0,0,.3)" : null;
            }
          });
        }

        function clearDiagram() {
            myDiagram.model = $$(go.GraphLinksModel,
            {
               linkFromPortIdProperty: 'fromPort',
               linkToPortIdProperty: 'toPort',
            });
        }

        function useFramework(id) { useFrameworkOrLaw('framework', id); }
        function useLaw(id) { useFrameworkOrLaw('law', id); }

        function useFrameworkOrLaw(type, id) {
            var currentFramework = parseInt($('#current_framework').val()),
                currentLaw = parseInt($('#current_law').val());
            $.ajax({
                url: "{{=URL('default', 'useFrameworkOrLaw', extension='json')}}",
                type: 'get',
                dataType: 'json',
                data: {
                    type: type,
                    id: id,
                    currentFramework: currentFramework,
                    currentLaw: currentLaw,
                },
                success: function(data) {
                    //if we received a new framework to use, clear the existing one from the palette
                    //and populate it with the new concepts
                    if(data.frameworks && data.frameworks.length > 0) {
                        myPalette.model = CORE_CONCEPTS;
                        data.frameworks.forEach(function(framework) {
                            framework.concepts.forEach(function(concept) {
                                myPalette.model.addNodeData({
                                    concept: concept.id, text: concept.name, figure: "RoundedRectangle", fill: "#88AD5F"
                                })
                            });
                        });
                        if(data.frameworks[0].id) $('#current_framework').val(data.frameworks[0].id);
                    }
                    //if we received a new law to use, clear the existing one from the graph
                    //and populate it with the new nodes
                    if(data.law && data.law.nodes) {
                        myDiagram.removeParts(myDiagram.nodes);
                        data.law.nodes.forEach(function(node) {
                        });
                        if(data.law.id) $('#current_law').val(data.law.id);
                    }
                },
                error: function() {
                }
            });
        }

        function saveLaw() {
            var id = $('#current_law').val();
            if(isNaN(id)) return;

            var nodes = [];
            myDiagram.nodes.each(function(node) {
                var data = {
                    'id': node.data['key'], 'law': id, 'concept': node.data['concept'],
                    'head': null, 'reference': null, 'predicate': null
                };
                var head = node.findNodesInto('T'),
                    reference = node.findNodesOutOf('T');
                if(head.count > 0) data['head'] = head.first().data['key'];
                if(reference.count > 0) data['reference'] = reference.first().data['key'];
                nodes.push(data);
            });

            $.ajax({
                url: "{{=URL('default', 'saveLaw', extension='json')}}",
                type: 'post',
                dataType: 'json',
                data: JSON.stringify({id: id, nodes: nodes}),
                success: function(data) {
                    $('#law-save-msg').val('Relation saved').show(3000);
                },
                error: function() {
                }
            });
        }

        function loadLaw(id) {
            $.ajax({
               url: "{{=URL('default', 'loadLaw', extension='json')}}",
               type: 'get',
               dataType: 'json',
               data: JSON.stringify({id: id}),
               success: function(data) {
               },
               error: function() {
               }
            });
        }

        /* RELATION EVALUATION

        Scheme: Start with the relation R.  For each node N, take its concept C, and find all laws L
        that have a predicate on C.  Trace the predicate of L up to its roots, all the while matching its
        nodes with those of the relation R.  If they all match up, retain the map between nodes of L and R.

        If two maps M1 and M2 for the same law, different predicate nodes P1 and P2, are found to intersect - that is,
        each node of R that is in both M1 and M2 maps to the same node of L - then we check for a logic (AND/OR) relation
        between P1 and P2 in L.  If there is one, we merge M1 and M2 into a new map M3 (still retaining M1 and M2),
        add the logic node(s) between P1 and P2 to our relation, and include it(them) in M3.

        When another map M4 is later merged with M3, we again combine the predicate nodes of M4 and M3 using logic nodes
        from L.  As we keep merging maps, eventually we will create a logic node in our relation that satisfies L.
        At that point, we can append to our relation R the additional knowledge (relations) that L provides us.

        If we maintain symmetric nodes, we can ensure that every map always has a unique deep node.  QUESTION: How do we
        store symmetric nodes that relate more than two inputs, ie. a sum, equality, or AND between three operands?

        */

        function Relation() {

            this.lawId = getCurrentLaw();

            this.nodes = {};
            this.allNodes = {};
            this.predicates = {};
            this.newNodes = {};

            this.wildcardConcept = 2;

            this.tempIdMap = null;
            this.nodeMap = {};
            this.map = {};
            this.nextMapId = 0;
            this.nextNodeId = 0;
        }

        function getCurrentLaw() {
            return $('#current_law').val();
        }

        //get and index relevant DB tables for use in the evaluation algorithm
        Relation.prototype.init = function() {

            var self = this;

            $.ajax({
               url: "{{=URL('default', 'initRelation', extension='json')}}",
               type: 'get',
               dataType: 'json',
               data: {},
               success: function(data) {
                   self.nodes = data.nodes;
                   self.allNodes = data.allNodes;
                   self.predicates = data.predicates;
               }
            });
        };

        Relation.prototype.evaluate = function() {

            var self = this, nodes = self.nodes.keys();

            while(nodes.length > 0) {
               //find any deep predicate nodes in included frameworks
               //that have the same concept as this node
               var nodeId = nodes.pop(), concept = self.nodes[nodeId]['concept'];
               if(!self.predicates.hasOwnProperty(concept)) return;
               self.predicates[concept].forEach(function(predicateId) {
                   self.checkPredicate(nodeId, predicateId);
               });
            });

            $.ajax({
               url: "{{=URL('default', 'saveNodes', extension='json')}}",
               type: 'post',
               dataType: 'json',
               data: JSON.stringify(self.newNodes),
               success: function(data) {
               },
            });
        };

        //see if the relation matches the predicate by recursively tracing the law up to its wildcards
        Relation.prototype.checkPredicate = function(nodeId, predicateId) {

            var self = this, node = this.nodes[nodeId], predicate = this.allNodes[predicateId];

            //if this is the first recursion step, initialize aggregators
            var firstLevel = self.tempIdMap == null;
            if(firstLevel) {
                self.tempIdMap = {};
                self.intersectCandidates = [];
            }

            //make sure this node's concept matches the predicate's concept
            var match = node['concept'] == predicate['concept'] || predicate['concept'] == this.wildcardConcept;
            if(!match) return false;

            self.tempIdMap[nodeId] = predicateId;
            self.tempIdMap[predicateId] = nodeId;

            //note any prior mappings between this node and predicate node - used later to test for intersections
            if(self.nodeMap.hasOwnProperty(nodeId) && self.nodeMap[nodeId].hasOwnProperty(predicateId)) {
                for(var map in self.nodeMap[nodeId][predicateId]) {
                    if(self.nodeMap[nodeId][predicateId].hasOwnProperty(map))
                        self.intersectCandidates.push(map);
                }
            }

            //check recursively on this node's head and reference
            var links = ['head', 'reference'];
            for(var i = 0; i < 2; i++) {
                var link = links[i], nodeLink = node[link], predicateLink = predicate[link];
                if(!predicateLink) continue;
                else if(!nodeLink || !self.checkPredicate(nodeLink, predicateLink)) return false;
            }

            if(firstLevel) {
                //at this point we have a complete match, so retain this ID map
                var count = 0;
                for(let node in self.tempIdMap) {
                    let predicate = self.tempIdMap[node];
                    if(!self.nodeMap.hasOwnProperty(node)) self.nodeMap[node] = {};
                    if(!self.nodeMap[node].hasOwnProperty(predicate)) self.nodeMap[node][predicate] = {};
                    if(!self.nodeMap.hasOwnProperty(predicate)) self.nodeMap[predicate] = {};
                    if(!self.nodeMap[predicate].hasOwnProperty(node)) self.nodeMap[predicate][node] = {};
                    self.nodeMap[node][predicate][self.nextMapId] = 1;
                    self.nodeMap[predicate][node][self.nextMapId] = 1;
                    count++;
                }
                if(count > 0) {
                    self.map[self.nextMapId++] = {
                        lawId: predicate['law'],
                        predicates: predicateId,
                        idMap: self.tempIdMap
                    };
                }
                self.tempIdMap = null;

                //also see if this ID map completely intersects any other ID maps
                self.intersectCandidates.forEach(function(mapId) {
                    self.checkIntersection(self.nextMapId-1, mapId);
                });
            }
            return true;
        };

        Relation.prototype.checkIntersection = function(mapId1, mapId2) {

            var self = this, map1 = self.map[mapId1], map2 = self.map[mapId2];

            //make sure the two maps are for the same law, but their predicate sets are disjoint
            if(map1.lawId != map2.lawId) return false;
            var disjoint = map1.predicates.every(function(predicate) {
                    return map2.predicates.indexOf(predicate) < 0;
                });
            if(!disjoint) return false;

            //and that the joint predicate set is part of a set that satisfies the law
            var law = self.laws[map1.lawId], predicateSet = map1.predicates.concat(map2.predicates);
            var match = null;
            var cannotCombine = law.predicateSets.every(function(set) {
                var isSubset = predicateSet.every(function(predicate) {
                    return set.indexOf(predicate) >= 0;
                }), isMatch = false;
                if(isSubset) {
                    //meanwhile, check if the predicates in the two maps in fact satisfy the law
                    isMatch = set.every(function(predicate) {
                        return predicateSet.indexOf(predicate) >= 0;
                    });
                    if(isMatch) match = set;
                }
                return !isSubset && !isMatch;
            });
            if(match == null && cannotCombine) return false;

            //whichever relation nodes are shared by the two maps must be mapped to the same predicate node
            for(let node in map1.idMap) {
                if(!map2.idMap.hasOwnProperty(node)) continue;
                if(map2.idMap[node] != map1.idMap[node]) return false;
            }

            //at this point they do intersect, so create a new map by merging these two
            var map = {
                lawId: map1.lawId,
                predicates: predicateSet,
                idMap: Object.assign({}, map1.idMap, map2.idMap)
            };
            self.map[self.nextMapId++] = map;

            //if the law has been satisfied, use the map to append the knowledge of the law to our relation
            if(match) {
                self.appendLaw(map);
            }

            return true;
        };

        //given a correspondence between nodes in the relation and predicate, fill in the rest of the law
        Relation.prototype.appendLaw = function(map) {

            var self = this;

            //start at each deep node of the law
            var law = this.laws[map.lawId];
            law.deepNodes.forEach(function(nodeId) {
               self.appendLawHelper(map, nodeId);
            });
        };

        Relation.prototype.appendLawHelper = function(map, nodeId) {

            var self = this, node = self.allNodes[nodeId], head = node['head'], reference = node['reference'], newHead, newReference;

            if(!map.idMap.hasOwnProperty(head)) newHead = self.appendLawHelper(map, head);
            else newHead = map.idMap[head];
            if(!map.idMap.hasOwnProperty(reference)) newReference = self.appendLawHelper(map, reference);
            else newReference = map.idMap[reference];

            var newId = self.nextNodeId++;
            self.newNodes[newId] = {
                'id': newId,
                'law': self.lawId,
                'concept': node['concept'],
                'head': newHead,
                'reference': newReference
            });
            map.idMap[nodeId] = newId;
            return newId;
        };

    </script>
    {{end page_js}}



    {{block page_css}}
    <style>
        html {
            height: 100%;
        }
        body {
            min-height: 100%;
            margin: 20px;
        }

        .concept {
            border: 3px solid red;
            border-radius: 4px;
            padding: 6px;
            font-size: 14px;
            color: black;
        }

        #editor-wrapper {
            display: table;
            width: 100%;
            height: 100%;
        }
        #editor-container {
            display: table-row;
            width: 100%;
            height: 100%;
        }
        #concept-container, #graph-container {
            display: table-cell;
        }
        #concept-container {
            width: 10%;
            height: 100%;
            border: 3px solid blue;
        }
        #graph-container {
            width: auto;
            height: 100%;
            border: 3px solid green;
        }

        #graph-save-button {
            border: 2px solid black;
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
            background-color: #aaaaff;
            color: black;
        }
    </style>
    {{end page_css}}

</html>