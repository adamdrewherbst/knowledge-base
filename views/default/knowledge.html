<html>

    <head>
        <link rel="stylesheet" href="{{=URL('static','css/bootstrap.min.css')}}"/>
        <link rel="stylesheet" href="{{=URL('static','css/web2py-bootstrap3.css')}}"/>
        <link rel="stylesheet" href="/welcome/static/GoJS-master/assets/css/main.css">
        <!--<link rel="stylesheet" href="/welcome/static/GoJS-master/assets/css/bootstrap.min.css">-->
        <link rel="stylesheet" href="/welcome/static/GoJS-master/assets/css/highlight.css">
        <link rel="stylesheet" href="/welcome/static/GoJS-master/assets/css/jquery-ui.min.css">
    </head>

    <body>

        <!-- form: create/modify concepts -->
        <!--<h2>Create a new concept</h2>
        {{=LOAD('default', 'concept.load', ajax=True)}}-->

        <!-- controls -->
        <div id="controls">
            <div class="entry-wrapper" table="framework">
                <button class="entry-set-button" type="button" class="btn btn-primary">Select Framework</button>
                <div class="entry-info">
                    <div class="entry-msg">Using Framework <span class="entry-name">NONE</span></div>
                    <button class="entry-edit-button" type="button" class="btn btn-primary">Edit</button>
                </div>
            </div>
            <div class="entry-wrapper" table="law">
                <button class="entry-set-button" type="button" class="btn btn-primary">Select Law</button>
                <div class="entry-info">
                    <div class="entry-msg">Using Law <span class="entry-name">NONE</span></div>
                    <button class="entry-edit-button" type="button" class="btn btn-primary">Edit</button>
                </div>
            </div>
        </div>

        <!-- graph editor -->
        <h2>Build a relation with concepts</h2>
        <div id="graph-buttons" style="margin-bottom: 20px">
            <div id="graph-controls">
                <div id="palette-controls">
                    <button id="concept-create-button" type="button" class="btn btn-primary">New Concept</button>
                    <select id="palette-concept-filter" class="framework-filter">
                        <option value="-1">-- Filter --</option>
                    </select>
                </div>
                <div id="predicate-controls">
                    <select id="set-predicate">
                        <option value="-1">Select Predicate</option>
                        <option value="new">New Predicate</option>
                    </select>
                    <button id="remove-predicate" type="button" class="btn btn-primary">Remove Predicate</button>
                    <label id="predicate-help">Right-click a node to add/remove it from this predicate</label>
                </div>
                <div id="relation-controls">
                    <button id="save-relation" type="button" class="btn btn-primary">Save Relation</button>
                    <button id="evaluate-relation" type="button" class="btn btn-primary">Evaluate</button>
                    <label id="evaluate-msg"></label>
                </div>
            </div>
        </div>
        <div style="width: 100%; display: flex; justify-content: space-between">
            <div id="concept-palette" style="width: 160px; margin-right: 2px; background-color: whitesmoke; border: solid 1px black"></div>
            <div id="graph-canvas" style="flex-grow: 1; height: 620px; border: solid 1px black"></div>
            <div id="node-info" style="display: inline-block; vertical-align: top;">
                <h3 id="node-title"></h3>
                <p id="node-description"></p>
            </div>
        </div>

        {{ =LOAD('default', 'entry.load', ajax=False, vars={'table': 'framework'}) }}
        {{ =LOAD('default', 'entry.load', ajax=False, vars={'table': 'law'}) }}
        {{ =LOAD('default', 'entry.load', ajax=False, vars={'table': 'concept'}) }}

        <div id="visualization">
            <div id="visualization-controls">
                <button id="visualize-relation" type="button" class="btn btn-primary">Visualize</button>
            </div>
            <canvas id="visualization-canvas">
            </canvas>
        </div>

    </body>



    {{block page_css}}
    <style>
        html {
            height: 100%;
        }
        body {
            min-height: 100%;
            margin: 20px;
        }

        .entry-wrapper {
            padding: 10px 0;
        }
        .entry-set-button {
            display: inline-block;
        }
        .entry-info {
            display: inline-block;
        }
        .entry-msg {
            display: inline-block;
            margin-right: 20px;
        }
        .entry-edit-button {
            display: inline-block;
        }


        .entry-modal .modal-dialog {
            width: 70%;
        }
        .entry-modal .nav-tabs {
            border-width: 2px;
        }
        .entry-modal .nav-tabs > li {
            font-size: 16px;
        }
        .entry-modal .nav-tabs > li > a {
            border-width: 2px;
        }
        .entry-modal .tab-content {
            padding: 10px;
        }
        .entry-modal .tab-pane > * {
            display: block;
            margin-bottom: 5px;
        }
        .entry-modal input, .entry-modal select, .entry-modal textarea {
            border-radius: 5px;
            font-size: 18px;
            background-color: #eff;
            color: #000;
        }
        .entry-modal .form-group label {
            display: block;
        }
        .entry-modal input {
            width: 50%;
        }
        .entry-modal textarea {
            width: 100%;
        }
        .entry-modal .result-display {
            padding: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            white-space: nowrap;
            overflow-x: hidden;
        }
        .entry-modal .result-display.selected {
            background-color: #ddf;
            border-radius: 10px;
        }
        .entry-modal .result-display > span {
            display: inline-block;
            white-space: nowrap;
            overflow-x: hidden;
        }
        .entry-modal .result-display > .result-name {
            width: 40%;
        }
        .entry-modal .result-display > .result-description {
        }
        .entry-modal .tab-footer {
            text-align: right;
        }


        .multiple-template {
            display: none;
        }



        /*.concept {
            border: 3px solid red;
            border-radius: 4px;
            padding: 6px;
            font-size: 14px;
            color: black;
        }*/

        #editor-wrapper {
            display: table;
            width: 100%;
            height: 100%;
        }
        #editor-container {
            display: table-row;
            width: 100%;
            height: 100%;
        }
        #concept-container, #graph-container {
            display: table-cell;
        }
        #concept-container {
            width: 10%;
            height: 100%;
            border: 3px solid blue;
        }
        #graph-container {
            width: auto;
            height: 100%;
            border: 3px solid green;
        }

        #graph-controls {
        }
        #predicate-controls, #relation-controls {
            margin-bottom: 20px;
        }
        #graph-controls button, #graph-controls select {
            padding: 5px 10px;
            border: 2px solid black;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            background-color: #aaaaff;
            color: black;
        }
        #predicate-controls {
            float: left;
        }
        #predicate-controls button {
        }
        #remove-predicate, #predicate-help {
            display: none;
        }
        #relation-controls {
            float: right;
        }
        #relation-controls button {
        }

        #node-info {
            background-color: #8ff;
            color: #604;
            font-weight: bold;
            padding: 0 20px;
        }


        #visualization {
        }
        #visualization-controls {
            margin: 20px 0;
        }
        #visualization-canvas {
            border: 3px solid green;
        }

    </style>
    {{end page_css}}




    {{block page_js}}
    {{include 'web2py_ajax.html'}}
    <script src="/welcome/static/GoJS-master/release/go.js"></script>
    <script src="/welcome/static/GoJS-master/assets/js/highlight.js"></script>
    <script src="/welcome/static/GoJS-master/assets/js/bootstrap.min.js"></script>
    <!--<script src="{{=URL('static', 'js/knowledge.js')}}"></script>-->
    <script type="application/javascript;version=1.7">
        var $$ = go.GraphObject.make;

        // This variation on ForceDirectedLayout does not move any selected Nodes
        // but does move all other nodes (vertexes).
        function ContinuousForceDirectedLayout() {
            go.ForceDirectedLayout.call(this);
            this._isObserving = false;
        }
        go.Diagram.inherit(ContinuousForceDirectedLayout, go.ForceDirectedLayout);

        /** @override */
        ContinuousForceDirectedLayout.prototype.isFixed = function(v) {
            return v.node.isSelected;
        }

        // optimization: reuse the ForceDirectedNetwork rather than re-create it each time
        /** @override */
        ContinuousForceDirectedLayout.prototype.doLayout = function(coll) {
            if (!this._isObserving) {
                this._isObserving = true;
                // cacheing the network means we need to recreate it if nodes or links have been added or removed or relinked,
                // so we need to track structural model changes to discard the saved network.
                var lay = this;
                this.diagram.addModelChangedListener(function (e) {
                    // modelChanges include a few cases that we don't actually care about, such as
                    // "nodeCategory" or "linkToPortId", but we'll go ahead and recreate the network anyway.
                    // Also clear the network when replacing the model.
                    if (e.modelChange !== "" ||
                            (e.change === go.ChangedEvent.Transaction && e.propertyName === "StartingFirstTransaction")) {
                        lay.network = null;
                    }
                });
            }
            var net = this.network;
            if (net === null) {  // the first time, just create the network as normal
                this.network = net = this.makeNetwork(coll);
            } else {  // but on reuse we need to update the LayoutVertex.bounds for selected nodes
                this.diagram.nodes.each(function (n) {
                    var v = net.findVertex(n);
                    if (v !== null) v.bounds = n.actualBounds;
                });
            }
            // now perform the normal layout
            go.ForceDirectedLayout.prototype.doLayout.call(this, coll);
            // doLayout normally discards the LayoutNetwork by setting Layout.network to null;
            // here we remember it for next time
            this.network = net;
        }
        // end ContinuousForceDirectedLayout


        function Entry() {
        }

        Entry.prototype.get = function(key) {
            return this[key];
        };

        Entry.prototype.set = function(key, value) {
            this[key] = value;
        };

        Entry.prototype.getId = function() {
            return this.id;
        };

        Entry.prototype.findEntry = function(table, id) {
            if(this.relation) return this.relation.findEntry(table, id);
            return null;
        };

        Entry.prototype.findId = function(table, opts) {
            let entries = this.relation.getTable(table);
            for(let id in entries) {
                let entry = entries[id], match = true;
                for(let key in opts) {
                    if(entry[key] != opts[key]) {
                        match = false;
                        break;
                    }
                }
                if(match) return id;
            }
            return null;
        };


        function Framework() {
        }

        Framework.prototype = Object.create(Entry.prototype);
        Framework.prototype.constructor = Framework;
        Framework.prototype.table = 'framework';


        function Concept() {
        }

        Concept.prototype = Object.create(Entry.prototype);
        Concept.prototype.constructor = Concept;
        Concept.prototype.table = 'concept';

        Concept.prototype.instanceOf = function(parent) {
            if(typeof parent == 'string') parent = this.findId(this.table, {name: parent});
            if(this.dependencies[parent]) return true;
            for(let dep in this.dependencies) {
                let concept = this.findEntry(this.table, dep);
                if(concept.instanceOf(parent)) return true;
            }
            return false;
        };


        function Law() {
            this.nodes = [];
        }

        Law.prototype = Object.create(Entry.prototype);
        Law.prototype.constructor = Law;
        Law.prototype.table = 'law';

        Law.prototype.getNodesByConcept = function(concept) {
            let nodes = [], self = this;
            this.nodes.forEach(function(id) {
                let node = self.findEntry('node', id);
                if(!node) return;
                let nodeConcept = node.getConcept();
                if(!nodeConcept) return;
                if((typeof concept == 'number' && nodeConcept.id == concept) || (typeof concept == 'string' && nodeConcept.name == concept))
                    nodes.push(node);
            });
            return nodes;
        };


        function Node() {
            this.children = {};
        }

        Node.prototype = Object.create(Entry.prototype);
        Node.prototype.constructor = Node;
        Node.prototype.table = 'node';

        Node.prototype.getConcept = function() {
            return this.findEntry('concept', this.concept);
        };

        Node.prototype.instanceOf = function(concept) {
            return this.getConcept().instanceOf(concept);
        };

        Node.prototype.getValue = function() {
            if(this.values && this.values.values.length == 1)
                return this.values.values[0];
            return null;
        };

        Node.prototype.getHead = function() {
            return this.findEntry(this.table, this.head);
        };

        Node.prototype.getReference = function() {
            return this.findEntry(this.table, this.reference);
        };

        Node.prototype.setHead = function(id) {
            let currentHead = this.findEntry('node', this.head);
            if(currentHead) currentHead.removeChild(this.id);
            this.head = id;
            let newHead = this.findEntry('node', this.head);
            if(newHead) newHead.addChild(this);
        };

        Node.prototype.setReference = function(id) {
            this.reference = id;
        };

        Node.prototype.addChild = function(node) {
            this.children[node.getId()] = node;
        };

        Node.prototype.getChildren = function() {
            let children = [];
            for(let id in this.children) {
                children.push(this.children[id]);
            }
            return children;
        };

        Node.prototype.getChildrenByConcept = function(concept) {
            let children = [];
            for(let id in this.children) {
                let child = this.children[id];
                if(child.instanceOf(concept)) children.push(child);
            }
            return children;
        };

        Node.prototype.removeChild = function(id) {
            delete this.children[id];
        };

        Node.prototype.remove = function() {
            this.setHead(null);
            if(this.relation) this.relation.removeEntry('node', this.id);
        };



        function Value(str) {
            this.opts = {};
            this.values = [];
            if(typeof str == 'string') this.readValue(str);
        }

        Value.prototype.get = function(key) {
            return this.opts[key];
        }

        Value.prototype.set = function(key, val) {
            this.opts[key] = val;
        };

        Value.prototype.empty = function() {
            return this.values.length == 0;
        };

        Value.prototype.addValue = function(value) {
            if(value == null) return;
            if(typeof value == 'object' && value.empty()) return;
            this.values.push(value);
        };

        Value.prototype.toString = function() {
            let str = '', delimStart = '', delimEnd = '';
            switch(this.get('type')) {
                case 'tuple':
                    delimStart = '{';
                    delimEnd = '}';
                    break;
                case 'interval':
                    delimStart = this.get('include.start') ? '[' : '(';
                    delimEnd = this.get('include.end') ? ']' : ')';
                    break;
                default: break;
            }
            str += delimStart;
            this.values.forEach(function(value) {
                if(typeof value == 'object')
                    str += value.toString();
                else str += value;
                str += ',';
            });
            str = str.substring(0, str.length-1) + delimEnd;
            return str;
        };

        Value.prototype.readValue = function(str) {
            let self = this, arr = str.split(';');
            arr.forEach(function(str) {
                if(str == '') return;
                if(!isNaN(str)) {
                    self.addValue(parseFloat(str));
                } else if(str[0] == '{') {
                    self.readTuple(str);
                } else if(str[0] == '(' || str[0] == '[') {
                    self.readInterval(str);
                }
            });
        };

        Value.prototype.readTuple = function(str) {
            let value = new Value();
            value.set('type', 'tuple');
            arr = str.substring(1, str.length-1).split(',');
            arr.forEach(function(str, i) {
                value.readValue(str);
            });
            this.addValue(value);
        };

        Value.prototype.readInterval = function(str) {
            let value = new Value();
            value.set('type', 'interval');
            if(str[0] == '(') value.set('include.start', false);
            else if(str[0] == '[') value.set('include.start', true);
            if(str[str.length-1] == ')') value.set('include.end', false);
            else if(str[str.length-1] == ']') value.set('include.end', true);
            arr = str.substring(1, str.length-1).split(',');
            value.readValue(arr[0]);
            value.readValue(arr[1]);
            this.addValue(value);
        };

        Value.prototype.includes = function(value) {
            if(value == null) return false;
            if(this.get('type') == value.get('type')) {
                switch(this.get('type')) {
                    case 'tuple':
                        let match = this.values.length == value.values.length;
                        if(match) for(let i = 0; i < this.values.length; i++) {
                            if(this.values[i] != value.values[i]) match = false;
                        }
                        if(match) return true;
                        break;
                    case 'interval':
                        let myStart = this.values[0], otherStart = value.values[0],
                            myEnd = this.values[1], otherEnd = value.values[1],
                            myIncludeStart = this.get('include.start'), myIncludeEnd = this.get('include.end'),
                            otherIncludeStart = value.get('include.start'), otherIncludeEnd = value.get('include.end');
                        let startIncluded = myStart < otherStart ||
                            (myStart == otherStart && myIncludeStart || !otherIncludeStart);
                        let endIncluded = myEnd > otherEnd ||
                            (myEnd == otherEnd && myIncludeEnd || !otherIncludeEnd);
                        if(startIncluded && endIncluded) return true;
                        break;
                    default: break;
                }
            }
        };

        Value.prototype.intersect = function(value) {
            return new Value();
        };


        /*********   RELATION   *****************

        A wrapper class for all functionality on this page

        *****************************************/

        function Relation() {

            this.paletteFramework = null;
            this.paletteFrameworks = [];

            this.frameworks = {};
            this.frameworks[-1] = new Framework();
            this.frameworks[-1].id = -1;
            this.frameworks[-1].relation = this;

            this.concepts = {};

            this.laws = {};
            this.laws[-1] = new Law();
            this.laws[-1].id = -1;
            this.laws[-1].relation = this;

            this.nodes = {};
            this.nodes[0] = new Node();
            this.nodes[0].id = 0;
            this.nodes[0].relation = this;

            this.predicates = {};

            this.myNodes = [];
            this.nodesToCheck = [];
            this.newNodes = [];

            this.tempIdMap = null;
            this.nodeMap = {};
            this.map = {};
            this.nextMapId = 0;
            this.nextNodeId = 0;

            this.nodeTemplates = {
                'default': {
                    shape: "RoundedRectangle",
                    fill: "#88AD5F"
                },
                'predicate': {
                    shape: "Rectangle",
                    fill: "yellow"
                },
                'appended': {
                    shape: 'RoundedRectangle',
                    fill: '#FF66AA'
                }
            };

            this.concepts = {};
            this.wildcardConcept = 2;

            this.predicateSets = [];
            this.currentPredicate = -1;
        }


        Relation.prototype.storeEntries = function(ajaxData) {
            let self = this;
            if(!ajaxData || typeof ajaxData.entries != 'object') return;
            console.log('storing entries');
            console.info(ajaxData.entries);
            for(let table in ajaxData.entries) {
                let data = ajaxData.entries[table], entries = self.getTable(table);
                if(!entries) return;
                let saved = {};

                //pre-processing
                for(let id in data) {
                    if(isNaN(id)) continue;
                    id = parseInt(id);
                    let oldId = data[id].oldId;
                    if(!entries.hasOwnProperty(id)) {
                        if(oldId && entries.hasOwnProperty(oldId)) {
                            entries[id] = entries[oldId];
                            delete entries[oldId];
                        } else entries[id] = self.createEntry(table);
                    }
                    let entry = entries[id];
                    switch(table) {
                        case 'framework': break;
                        case 'law': break;
                        case 'concept': break;
                        case 'node':
                            let head = entry.getHead();
                            if(head && data[id].head != head.id) head.removeChild(id);
                            break;
                        default: break;
                    }
                    //overwriting
                    for(let key in data[id]) {
                        entry.set(key, data[id][key]);
                    }
                    saved[id] = true;
                }

                //post-processing
                let frameworkReset = false;
                for(let id in saved) {
                    let entry = entries[id], oldId = data[id].oldId;
                    switch(table) {
                        case 'framework':
                            if(self.framework.id == id || self.framework.id == oldId) {
                                self.setFramework(entry);
                                frameworkReset = true;
                            }
                            break;
                        case 'law':
                            entry.predicateSets = [];
                            if(self.law.id == entry.id || self.law.id == oldId) {
                                self.setLaw(entry);
                            }
                            $.each(entry.predicates, function(id, group) {
                                let pset = [];
                                for(let node in group) pset.push(parseInt(node));
                                entry.predicateSets.push(pset);
                            });
                            entry.deepNodes = [];
                            entry.nodes.forEach(function(node) {
                                let n = parseInt(node);
                                if(!entry.notDeepNode.hasOwnProperty(n)) {
                                    entry.deepNodes.push(n);
                                }
                            });
                            break;
                        case 'concept':
                            let graphs = [self.palette, self.diagram];
                            for(let i = 0; i < graphs.length; i++) {
                                let graph = graphs[i], found = false;
                                graph.nodes.each(function(node) {
                                    if(node.data.concept == id) {
                                        found = true;
                                        graph.model.set(node.data, 'concept', id);
                                        graph.model.set(node.data, 'framework', data[id].framework);
                                        graph.model.updateTargetBindings(node.data, 'concept');
                                    }
                                });
                                if(graph === self.palette && !found) {
                                    graph.model.addNodeData({
                                        concept: id,
                                        framework: data[id].framework,
                                        visible: self.isVisibleInPalette(id)
                                    });
                                }
                            }
                            break;
                        case 'node':
                            if(typeof entry.values == 'string') entry.values = new Value(entry.values);
                            else if(!entry.values) entry.values = new Value();
                            entries[entry.head || 0].children[entry.id] = entry;
                            if(!self.predicates.hasOwnProperty(entry.concept)) self.predicates[entry.concept] = {};
                            self.predicates[entry.concept][entry.id] = true;
                            let nodeData = self.diagram.model.findNodeDataForKey(id);
                            if(!nodeData && oldId) nodeData = self.diagram.model.findNodeDataForKey(oldId);
                            if(nodeData) {
                                for(let key in entry)
                                    if(nodeData.hasOwnProperty(key))
                                        self.diagram.model.set(nodeData, key, entry[key]);
                                self.diagram.model.updateTargetBindings(nodeData);
                            }
                            break;
                        default: break;
                    }
                }
                if(frameworkReset) self.filterPalette();
            }
        }


        Relation.prototype.createEntry = function(table) {
            let self = this, entry = null;
            switch(table) {
                case 'framework': entry = new Framework(); break;
                case 'law': entry = new Law(); break;
                case 'concept': entry = new Concept(); break;
                case 'node': entry = new Node(); break;
                default: break;
            }
            if(entry) {
                entry.relation = self;
            }
            return entry;
        };


        Relation.prototype.findEntry = function(table, id) {
            let self = this, entries = self.getTable(table);
            if(entries && entries.hasOwnProperty(id)) return entries[id];
            return null;
        };


        Relation.prototype.removeEntry = function(table, id) {
            let self = this, entries = self.getTable(table);
            if(entries && entries.hasOwnProperty(id)) delete entries[id];
        };


        Relation.prototype.getTable = function(name) {
            let self = this;
            switch(name) {
                case 'concept': return self.concepts; break;
                case 'framework': return self.frameworks; break;
                case 'node': return self.nodes; break;
                case 'law': return self.laws; break;
                default: break;
            }
            return null;
        };


        Relation.prototype.initDiagram = function() {
            let self = this;
            self.diagram = $$(go.Diagram, "graph-canvas",  // must name or refer to the DIV HTML element
            {
              grid: $$(go.Panel, "Grid",
                      $$(go.Shape, "LineH", { stroke: "lightgray", strokeWidth: 0.5 }),
                      $$(go.Shape, "LineH", { stroke: "gray", strokeWidth: 0.5, interval: 10 }),
                      $$(go.Shape, "LineV", { stroke: "lightgray", strokeWidth: 0.5 }),
                      $$(go.Shape, "LineV", { stroke: "gray", strokeWidth: 0.5, interval: 10 })
                    ),
              allowDrop: true,  // must be true to accept drops from the Palette
/*              layout:
                $$(ContinuousForceDirectedLayout,  // automatically spread nodes apart while dragging
                  { defaultSpringLength: 30, defaultSpringStiffness: 0, defaultElectricalCharge: 100 }),
              // do an extra layout at the end of a move
              "SelectionMoved": function(e) { e.diagram.layout.invalidateLayout(); },
//*/          "draggingTool.dragsLink": true,
              "draggingTool.isGridSnapEnabled": true,
              "linkingTool.isUnconnectedLinkValid": true,
              "linkingTool.portGravity": 20,
              "relinkingTool.isUnconnectedLinkValid": true,
              "relinkingTool.portGravity": 20,
              "relinkingTool.fromHandleArchetype":
                $$(go.Shape, "Diamond", { segmentIndex: 0, cursor: "pointer", desiredSize: new go.Size(8, 8), fill: "tomato", stroke: "darkred" }),
              "relinkingTool.toHandleArchetype":
                $$(go.Shape, "Diamond", { segmentIndex: -1, cursor: "pointer", desiredSize: new go.Size(8, 8), fill: "darkred", stroke: "tomato" }),
              "linkReshapingTool.handleArchetype":
                $$(go.Shape, "Diamond", { desiredSize: new go.Size(7, 7), fill: "lightblue", stroke: "deepskyblue" }),
              //rotatingTool: $(TopRotatingTool),  // defined below
              //"rotatingTool.snapAngleMultiple": 15,
              //"rotatingTool.snapAngleEpsilon": 15,
              "undoManager.isEnabled": true,
              "ChangedSelection": onSelectionChanged
            });

            function onSelectionChanged(e) {
                var node = e.diagram.selection.first();
                if (!(node instanceof go.Node)) return;
                var data = node.data;
                var title = document.getElementById('node-title');
                var description = document.getElementById('node-description');

                title.textContent = "Node Info";
                description.innerHTML = self.getNodeString(data.id).replace(new RegExp("\n", 'g'), "<br>");
            }

            // dragging a node invalidates the Diagram.layout, causing a layout during the drag
            self.diagram.toolManager.draggingTool.doMouseMove = function() {
              go.DraggingTool.prototype.doMouseMove.call(this);
              if (this.isActive) { this.diagram.layout.invalidateLayout(); }
            }

            // when the document is modified, add a "*" to the title and enable the "Save" button
            self.diagram.addDiagramListener("Modified", function(e) {
              var button = document.getElementById("graph-save-button");
              if (button) button.disabled = !self.diagram.isModified;
              var idx = document.title.indexOf("*");
              if (self.diagram.isModified) {
                if (idx < 0) document.title += "*";
              } else {
                if (idx >= 0) document.title = document.title.substr(0, idx);
              }
            });

            function makePort(name, spot, output, input, fromMax, toMax) {
                // the port is basically just a small transparent square
                var options =
                {
                    fill: null,  // not seen, by default; set to a translucent gray by showSmallPorts, defined below
                    stroke: null,
                    desiredSize: new go.Size(7, 7),
                    alignment: spot,  // align the port on the main Shape
                    alignmentFocus: spot,  // just inside the Shape
                    portId: name,  // declare this object to be a "port"
                    fromSpot: spot, toSpot: spot,  // declare where links may connect at this port
                    fromLinkable: output, toLinkable: input,  // declare whether the user may draw links to/from here
                    cursor: "pointer"  // show a different cursor to indicate potential link point
                };
                if(fromMax !== undefined) options.fromMaxLinks = fromMax;
                if(toMax !== undefined) options.toMaxLinks = toMax;
                return $$(go.Shape, "Circle", options);
            }

            function showSmallPorts(node, show) {
              node.ports.each(function(port) {
                if (port.portId !== "") {  // don't change the default port, which is the big shape
                  port.fill = show ? "rgba(0,0,0,.3)" : null;
                }
              });
            }

            // To simplify this code we define a function for creating a context menu button:
            function makeButton(text, action, visiblePredicate) {
              return $$("ContextMenuButton",
                       $$(go.TextBlock, text),
                       { click: action },
                       // don't bother with binding GraphObject.visible if there's no predicate
                       visiblePredicate ? new go.Binding("visible", "", function(o, e) { return o.diagram ? visiblePredicate(o, e) : false; }).ofObject() : {});
            }

            // a context menu is an Adornment with a bunch of buttons in them
            var partContextMenu =
              $$(go.Adornment, "Vertical",
                    makeButton("Rename",
                            function(e, obj) {
                                let part = obj.part.adornedPart;
                                if(!(part instanceof go.Node)) return;
                                let name = prompt('Enter new name');
                                if(name) self.setNodeData(part.data.id, 'name', name);
                            },
                            function(o) {
                                let part = o.part.adornedPart;
                                return part.diagram === self.diagram;
                            }),
                    makeButton("Change Concept",
                            function(e, obj) {
                                let part = obj.part.adornedPart;
                                if(!(part instanceof go.Node)) return;
                                let currentConcept = self.findEntry('concept', part.data.concept);
                                self.selectEntry('concept', function(concept) {
                                    if(concept && self.concepts.hasOwnProperty(concept))
                                        self.setNodeData(part.data.id, 'concept', concept);
                                },
                                {
                                    tab: 'create',
                                    fields: {
                                        framework: currentConcept.framework,
                                        law_specific: true,
                                        law: self.law.id,
                                        dependencies: [{dependencies: currentConcept.id}]
                                    }
                                });
                            },
                            function(o) {
                                let part = o.part.adornedPart;
                                return part.diagram === self.diagram;
                            }),
                    makeButton("Edit Concept",
                            function(e, obj) {
                                let part = obj.part.adornedPart;
                                if(!(part instanceof go.Node)) return;
                                self.editEntry('concept', part.data.concept);
                            },
                            function(o) {
                                return true;
                            }),
                    makeButton("Set Values",
                            function(e, obj) {
                                let part = obj.part.adornedPart;
                                if(!(part instanceof go.Node)) return;
                                let input = prompt("Enter a set of real numbers in interval notation, e.g. [0.5,2];5.7;[3,9);(9,17)");
                                let values = new Value(input);
                                if(values.empty()) return;
                                part.data.values = input;
                                if(self.nodes.hasOwnProperty(part.data.id)) self.nodes[part.data.id].values = values;
                            },
                            function(o) {
                                let part = o.part.adornedPart;
                                return part.diagram === self.diagram;
                            }),
                    makeButton("Add to Predicate",
                            function(e, obj) {
                                let part = obj.part.adornedPart;
                                if(part instanceof go.Node) self.togglePredicate(parseInt(part.data.id), true);
                            },
                            function(o) {
                                let part = o.part.adornedPart;
                                if(part.diagram !== self.diagram) return false;
                                if(part instanceof go.Node) return self.currentPredicate >= 0 && !self.inPredicate(parseInt(part.data.id));
                                return false;
                            }),
                    makeButton("Remove from Predicate",
                            function(e, obj) {
                                let part = obj.part.adornedPart;
                                if(part instanceof go.Node) self.togglePredicate(parseInt(part.data.id), false);
                            },
                            function(o) {
                                let part = o.part.adornedPart;
                                if(part.diagram !== self.diagram) return false;
                                if(part instanceof go.Node) return self.inPredicate(parseInt(part.data.id));
                                return false;
                            })
              );

            let infoString = function(obj) {
                let part = obj.part;
                if (part instanceof go.Adornment) part = part.adornedPart;
                let msg = "";
                if (part instanceof go.Link) {
                    msg = "";
                } else if (part instanceof go.Node) {
                    msg = self.getNodeString(part.data.id);
                }
                return msg;
            };

            self.diagram.nodeTemplate = $$(go.Node, "Spot",
                {
                    locationSpot: go.Spot.Center,
                    toolTip:
                      $$(go.Adornment, "Auto",
                        $$(go.Shape, { fill: "#EFEFCC" }),
                        $$(go.TextBlock, { margin: 4, width: 140 },
                          new go.Binding("text", "", infoString).ofObject())
                      )
                },
                new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
                new go.Binding("visible", "visible"),
                new go.Binding("angle").makeTwoWay(),
                // the main object is a Panel that surrounds a TextBlock with a Shape
                $$(go.Panel, "Auto",
                  { name: "PANEL" },
                  new go.Binding("desiredSize", "size", go.Size.parse).makeTwoWay(go.Size.stringify),
                  $$(go.Shape, self.nodeTemplates['default'].shape,  // default figure
                    {
                      cursor: "pointer",
                      fill: self.nodeTemplates['default'].fill,  // default color
                      strokeWidth: 2
                    },
                    new go.Binding("figure"),
                    new go.Binding("fill")),
                  $$(go.TextBlock,
                    {
                      font: "bold 11pt Helvetica, Arial, sans-serif",
                      margin: 8,
                      maxSize: new go.Size(160, NaN),
                      wrap: go.TextBlock.WrapFit,
                      editable: true
                    },
                    new go.Binding("text", "", function(data, node) {
                        if(node.diagram === self.palette) return self.concepts[data.concept].name;
                        let text = '';
                        if(typeof data.name == 'string' && data.name.length > 0) {
                            text = data.name;
                        } else if(data.concept && self.concepts.hasOwnProperty(data.concept)) {
                            text = self.concepts[data.concept].name;
                        }
                        text += ' [' + data.id + ']';
                        return text;
                    }))
                ),
                //port on top for head/reference, port on bottom for properties/referrers
                makePort("T", go.Spot.Top, true, true, 1, 1),
                makePort("B", go.Spot.Bottom, true, true),
                { // handle mouse enter/leave events to show/hide the ports
                    mouseEnter: function(e, node) { showSmallPorts(node, true); },
                    mouseLeave: function(e, node) { showSmallPorts(node, false); },
                    contextMenu: partContextMenu
                }
            );

            // initialize the Palette that is on the left side of the page
            self.palette = $$(go.Palette, "concept-palette",  // must name or refer to the DIV HTML element
            {
                maxSelectionCount: 1,
                nodeTemplateMap: self.diagram.nodeTemplateMap,  // share the templates used by the diagram
            });

            self.palette.layout.comparer = function(a, b) {
                let c1 = a.data.concept, c2 = b.data.concept;
                if(c1 && c2 && self.concepts.hasOwnProperty(c1) && self.concepts.hasOwnProperty(c2))
                    return self.concepts[c1].name.localeCompare(self.concepts[c2].name);
                return 0;
            };

            self.setPaletteModel();
            self.clearDiagram();

            let canvas = document.getElementById('visualization-canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            self.canvas = canvas.getContext('2d');
        };


        Relation.prototype.updateFields = function(element) {
            let self = this;
            let $element = element ? $(element) : $(document);
            $element.find('select[select-table]').each(function() {
                let $this = $(this), table = $this.attr('select-table');
                $this.children().first().nextAll().remove();
                let entries = self.getTable(table), sorted = [];
                for(let id in entries) {
                    if(id < 0) continue;
                    let i = 0, name = entries[id].name;
                    while(i < sorted.length && name.localeCompare(entries[sorted[i]].name) > 0) i++;
                    sorted.splice(i, 0, id);
                }
                sorted.forEach(function(id) {
                    $this.append('<option value="' + id + '">' + entries[id].name + '</select>');
                });
            });
        };


        Relation.prototype.setNodeData = function(nodeId, attr, value) {
            console.log('setting node ' + nodeId + ' ' + attr + ' to ' + value);
            let self = this, node = self.nodes[nodeId];
            if(node) node[attr] = value;
            let data = self.diagram.model.findNodeDataForKey(nodeId);
            if(data) self.diagram.model.set(data, attr, value);
        };


        Relation.prototype.getNodeString = function(id) {

            let self = this, node = self.nodes[id], law = self.law;
            if(!node) return '';

            let lawStr = '';
            if(law) lawStr = law.name + ' [' + law.id + ']';
            else lawStr = 'none';

            let predicates = '';
            for(let group in self.predicateSets) {
                if(self.predicateSets[group].hasOwnProperty(id)) {
                    let groupStr = '';
                    for(let n in self.predicateSets[group]) groupStr += '' + n + ',';
                    predicates += groupStr.substring(0, groupStr.length-1) + '; ';
                }
            }
            if(predicates == '') predicates = 'none';
            else predicates = predicates.substring(0, predicates.length-2);

            let mappings = '';
            if(self.nodeMap.hasOwnProperty(id)) {
                for(let p in self.nodeMap[id]) {
                    for(let m in self.nodeMap[id][p]) {
                        let map = self.map[m], law = self.laws[map.lawId];
                        let mapStr = '';
                        for(let n in map.idMap) if(self.nodes[n].law == law.id) mapStr += '' + n + ',';
                        mapStr = mapStr.substring(0, mapStr.length-1);
                        mappings += '' + p + ' [' + self.concepts[self.nodes[p].concept].name + ']' + "\n"
                            + '.  in ' + law.name + ' [' + law.id + ']' + "\n"
                            + '.  ' + mapStr + ' (map ' + m + ')' + "\n";
                    }
                }
            }
            if(mappings == '') mappings = 'none';
            else mappings = "\n" + mappings;

            msg = 'ID: ' + node.id + "\n"
                + 'Law: ' + lawStr + "\n"
                + 'Predicates: ' + predicates + "\n"
                + 'Values: ' + node.values.toString() + "\n"
                + 'Mappings: ' + mappings;
            return msg;
        };


        Relation.prototype.setPaletteModel = function() {
            let self = this, concepts = self.concepts;
            let dataArray = [];
            for(let id in concepts) {
                let concept = concepts[id];
                dataArray.push({
                    concept: concept.id,
                    framework: concept.framework,
                    visible: self.framework.id <= 0 || concept.framework == self.framework.id
                });
            }
            self.palette.model = $$(go.GraphLinksModel, {
                nodeDataArray: dataArray,
                linkDataArray: []
            });
        };


        Relation.prototype.filterPalette = function(framework) {
            let self = this;

            if(framework === undefined) framework = self.framework.id;
            self.paletteFramework = framework;
            let frameworks = [];
            if(framework < 0) {
                frameworks.push(undefined);
                if(self.framework.id >= 0) frameworks.push(self.framework.id);
                let ind = 1;
                while(ind < frameworks.length) {
                    let f = frameworks[ind];
                    for(let dep in self.frameworks[f].dependencies) {
                        if(frameworks.indexOf(dep) < 0) frameworks.push(dep);
                    }
                    ind++;
                }
            } else frameworks.push(framework);
            self.paletteFrameworks = frameworks;

            self.palette.nodes.each(function(node) {
                self.palette.model.set(node.data, 'visible', self.isVisibleInPalette(node.data.concept));
            });
        }


        Relation.prototype.isVisibleInPalette = function(conceptId) {
            let self = this, concept = self.concepts[conceptId];
            if(concept.law > 0) return concept.law == self.law.id;
            for(let i = 0; i < self.paletteFrameworks.length; i++)
                if(self.paletteFrameworks[i] == concept.framework)
                    return true;
            return false;
        };


        Relation.prototype.clearDiagram = function() {
            let self = this;
            self.diagram.model = $$(go.GraphLinksModel,
            {
                nodeKeyProperty: 'id',
                linkFromPortIdProperty: 'fromPort',
                linkToPortIdProperty: 'toPort',
            });
        };


        Relation.prototype.draw = function() {
            let self = this;
            self.diagram.removeParts(self.diagram.nodes);
            //start by arranging the nodes visually as a tree descending from the root,
            //then allow the force layout to adjust them
            //=> first we need to identify the children of each node
            let rootNodes = [];
            let nodeMeta = {'-1': {children: []}};
            self.myNodes.forEach(function(node) {
                nodeMeta[node] = {children: []};
            });
            self.myNodes.forEach(function(node) {
                if(node < 0) return;
                let head = self.nodes[node].head, root = !head;;
                nodeMeta[root ? -1 : head].children.push(node);
                if(root) nodeMeta[node].level = 0;
            });

            let horizontal = 100, vertical = 100;
            let getOffsets = function(node) {
                let nc = nodeMeta[node].children.length, width = horizontal;
                if(nc > 0) {
                    width = 0;
                    nodeMeta[node].children.forEach(function(child) {
                        nodeMeta[child].offset = width;
                        width += getOffsets(child);
                    });
                    nodeMeta[node].children.forEach(function(child) {
                        nodeMeta[child].offset -= width / 2 - horizontal / 2;
                    });
                }
                nodeMeta[node].width = width;
                return width;
            };
            getOffsets(-1);

            let drawNodes = function(node, x, y) {
                if(node >= 0) {
                    self.drawNode(node, {
                        loc: '' + x + ' ' + y,
                    });
                }
                nodeMeta[node].children.forEach(function(child) {
                    drawNodes(child, x + nodeMeta[child].offset, y + 100);
                });
            };
            drawNodes(-1, self.diagram.viewportBounds.width/2, 50);

            let drawLinks = function(node) {
                if(node >= 0) self.drawLinks(node);
                nodeMeta[node].children.forEach(function(child) {
                    drawLinks(child);
                });
            };
            drawLinks(-1);

            self.predicateSets = [];
            $('#set-predicate').children().slice(1, -1).remove();
            if(self.law.predicates) {
                for(let group in self.law.predicates) {
                    $('#set-predicate > option:last-child').before('<option value="' + (group-1) + '">Predicate ' + group + '</option>');
                    let obj = {};
                    for(let node in self.law.predicates[group]) obj[node] = true;
                    self.predicateSets.push(obj);
                }
            }
        };


        Relation.prototype.drawNode = function(nodeId, options) {

            let self = this, node = self.nodes[nodeId];

            if(!options) options = {};
            let template = {};
            if(options.template) {
                if(self.nodeTemplates.hasOwnProperty(options.template))
                    template = self.nodeTemplates[options.template];
            }
            let drawLinks = options.drawLinks ? true : false;
            delete options.template, options.drawLinks;

            let nodeData = Object.assign({}, node, options, template);
            nodeData.values = node.values.toString();
            if(!nodeData.hasOwnProperty('loc') && nodeData.head && nodeData.reference
              && self.nodes.hasOwnProperty(nodeData.head) && self.nodes.hasOwnProperty(nodeData.reference)) {
                let head = self.diagram.model.findNodeDataForKey(nodeData.head),
                    reference = self.diagram.model.findNodeDataForKey(nodeData.reference);
                let headLoc = head.loc.split(' '), refLoc = reference.loc.split(' ');
                let x = (parseFloat(headLoc[0]) + parseFloat(refLoc[0])) / 2,
                    y = Math.max(parseFloat(headLoc[1]), parseFloat(refLoc[1])) + 75;
                nodeData.loc = '' + x + ' ' + y;
            }
            self.diagram.model.addNodeData(nodeData);

            if(drawLinks) self.drawLinks(nodeId);
        };


        Relation.prototype.drawLinks = function(nodeId) {
            let self = this, node = self.nodes[nodeId];
            if(node.head) {
                self.diagram.model.addLinkData({from: node.head, to: node.id, fromPort: 'B', toPort: 'T'});
            }
            if(node.reference) {
                self.diagram.model.addLinkData({from: node.id, to: node.reference, fromPort: 'T', toPort: 'B'});
            }
        };


        Relation.prototype.setNodeTemplate = function(node, template) {
            let self = this;
            if(!self.nodeTemplates.hasOwnProperty(template)) return false;
            if(typeof node != 'object') {
                if(isNaN(node)) return false;
                node = self.diagram.model.findNodeDataForKey(node);
                if(!node) return false;
            }
            let nodeTemplate = self.nodeTemplates[template];
            for(let property in nodeTemplate) {
                self.diagram.model.setDataProperty(node, property, nodeTemplate[property]);
            }
        };


        Relation.prototype.setPredicate = function(predicate) {
            let self = this;
            //first un-highlight any selected predicate nodes
            self.diagram.nodes.each(function(node) {
                self.setNodeTemplate(node.data, 'default');
            });

            if(predicate < 0) {
                $('#remove-predicate, #predicate-help').hide();
                return;
            }

            //create a new empty predicate set if requested
            if(predicate == 'new') {
                predicate = self.predicateSets.length;
                self.predicateSets.push({});
                let $select = $('#set-predicate');
                $select.find('[value="new"]').before('<option value="' + predicate + '">Predicate ' + (predicate+1) + '</option>');
                $select.val(predicate);
            }

            $('#remove-predicate, #predicate-help').show();

            //now highlight nodes that are part of the chosen predicate
            for(let node in self.predicateSets[predicate]) {
                self.setNodeTemplate(node, 'predicate');
            }
            self.currentPredicate = predicate;
        };


        Relation.prototype.removePredicate = function(predicate) {
            let self = this;
            if(predicate === undefined) predicate = self.currentPredicate;
            if(isNaN(predicate)) return false;
            if(self.currentPredicate == predicate) {
                self.setPredicate(-1);
                $('#set-predicate').val(0);
            }
            self.predicateSets.splice(predicate, 1);
            let $option = $('#set-predicate > option[value="' + predicate + '"]').val("");
            $option.nextAll().each(function(i, el) {
                el.value = parseInt(el.value) - 1;
                el.text = 'Predicate ' + el.value;
            });
            $option.remove();
        };


        Relation.prototype.togglePredicate = function(node, include) {
            let self = this;
            if(!self.predicateSets.hasOwnProperty(self.currentPredicate)) return false;
            if(include) {
                self.predicateSets[self.currentPredicate][node] = true;
                self.setNodeTemplate(node, 'predicate');
            } else {
                delete self.predicateSets[self.currentPredicate][node];
                self.setNodeTemplate(node, 'default');
            }
        };


        Relation.prototype.inPredicate = function(node) {
            let self = this;
            if(isNaN(node)) return false;
            return self.predicateSets.hasOwnProperty(self.currentPredicate)
                && self.predicateSets[self.currentPredicate].hasOwnProperty(node);
        };


        Relation.prototype.useFramework = function(id) {
            let self = this;
            self.setFramework(id);

            if(!self.framework.loaded) {
                $.ajax({
                    url: "{{=URL('default', 'loadFramework', extension='json')}}",
                    type: 'get',
                    dataType: 'json',
                    data: {
                        framework: self.framework.id
                    },
                    success: function(data) {
                        self.predicates = {};
                        self.storeEntries(data);

                        if(data.hasOwnProperty('nextNodeId')) self.nextNodeId = parseInt(data.nextNodeId);

                        self.setPaletteModel();
                        self.filterPalette();
                        self.updateFields();
                    }
                });
            } else {
                self.setPaletteModel();
                self.filterPalette();
            }
        };


        Relation.prototype.setFramework = function(framework) {
            let self = this;
            if(!isNaN(framework)) framework = self.findEntry('framework', framework);
            if(!framework) return;
            self.framework = framework;
            $('.entry-wrapper[table=framework] .entry-name').text(self.framework.name || 'None');

            let $filters = $('.framework-filter');
            let options = [];
            if(self.framework.id > 0) options.push(self.framework.id);
            for(let i = 0; i < options.length; i++) {
                let fw = options[i], framework = self.frameworks[fw];
                for(let dep in framework.dependencies) {
                    if(options.indexOf(dep) < 0) options.push(dep);
                }
            }
            $filters.children().first().nextAll().remove();
            options.forEach(function(option) {
                el = '<option value="' + option + '">' + self.frameworks[option].name + '</option>';
                $filters.append(el);
            });
            $filters.val(self.framework.id);
        };


        Relation.prototype.useLaw = function(id) {
            let self = this;
            if(self.law.id == id) return;
            self.setLaw(id);
            if(self.law.framework != self.framework.id)
                self.useFramework(self.law.framework);
            self.myNodes = self.law.nodes;
            self.draw();
        };


        Relation.prototype.setLaw = function(law) {
            let self = this;
            if(!isNaN(law)) law = self.findEntry('law', law);
            if(!law) return;
            self.law = law;
            $('.entry-wrapper[table=law] .entry-name').text(self.law.name || 'None');
        };


        Relation.prototype.save = function() {
            let self = this, id = self.law.id;

            let nodes = [], predicates = [];
            self.syncGraph();
            self.law.nodes.forEach(function(id) {
                let node = self.findEntry('node', id);
                if(node) nodes.push({id: node.id, concept: node.concept, name: node.name, head: node.head,
                    reference: node.reference, values: node.values.toString()});
            });
            self.predicateSets.forEach(function(pset, i) {
                for(let node in pset) {
                    predicates.push({'node': parseInt(node), 'predicate_group': i+1});
                }
            });

            $.ajax({
                url: "{{=URL('default', 'saveRelation', extension='json')}}",
                type: 'post',
                dataType: 'json',
                data: JSON.stringify({id: id, framework: self.framework.id, nodes: nodes, predicates: predicates}),
                success: function(data) {
                    self.storeEntries(data);
                    $('#law-save-msg').val('Relation saved').show(3000);
                },
                error: function() {
                }
            });
        };


        Relation.prototype.syncGraph = function() {
            let self = this, graphNodes = [];
            self.diagram.nodes.each(function(node) {
                let id = parseInt(node.data['id']);
                let entries = self.getTable('node');
                if(!entries.hasOwnProperty(id)) entries[id] = self.createEntry('node');
                let entry = entries[id];
                entry.id = id;
                entry.concept = node.data['concept'];
                entry.name = node.data['name'] || null;
                entry.values = new Value(node.data['values']);
                let head = node.findNodesInto('T'),
                    reference = node.findNodesOutOf('T');
                head = head.count > 0 ? head.first().data['id'] : null;
                reference = reference.count > 0 ? reference.first().data['id'] : null;
                entry.setHead(head);
                entry.setReference(reference);
                if(graphNodes.indexOf(id) < 0) graphNodes.push(id);
            });

            self.law.nodes.forEach(function(id) {
                let node = self.findEntry('node', id);
                if(node && graphNodes.indexOf(id) < 0) {
                    node.remove();
                }
            });
            self.law.nodes = graphNodes;
        };


        /*

        RELATION EVALUATION:

        Scheme: Start with the relation R.  For each node N, take its concept C, and find all laws L
        that have a predicate on C.  Trace the predicate of L up to its roots, all the while matching its
        nodes with those of the relation R.  If they all match up, retain the map between nodes of L and R.

        If two maps M1 and M2 for the same law, different predicate nodes P1 and P2, are found to intersect - that is,
        each node of R that is in both M1 and M2 maps to the same node of L, and each node of L that is in both M1 and M2
        maps to the same node of R - then we check for a logic (AND/OR) relation between P1 and P2 in L.  If there is one,
        we merge M1 and M2 into a new map M3 (still retaining M1 and M2).

        When another map M4 is later merged with M3, we again combine the predicate nodes of M4 and M3 using logic
        from L.  As we keep merging maps, eventually we may have a map whose predicate nodes completely satisfy L.
        At that point, we can append to our relation R the additional knowledge (relations) that L provides us.

        *Symmetry*:

        Certain concepts, eg. sum, product, equality, are symmetric.  Within the tree rooted at a predicate node, if there
        is a symmetric node, we can flip its subtree relative to our relation, and if both orientations match, they give
        us two alternative submaps within the full map for that predicate node.

        So a given predicate map has 2^n alternative configurations where n is the number of symmetric nodes that matched
        in both orientations.  We make a separate map for each configuration.  Then we check all intersections with any of
        those 2^n maps.

        */

        Relation.prototype.evaluate = function() {

            $('#evaluate-msg').text('Evaluating...');
            self.syncGraph();
            self.nodesToCheck = self.myNodes.slice();
            while(self.nodesToCheck.length > 0) {
               //find any deep predicate nodes in included frameworks
               //that have the same concept as this node
               var nodeId = self.nodesToCheck.pop(), concept = self.nodes[nodeId]['concept'], concepts = [concept];
               for(let dep in self.concepts[concept].dependencies) concepts.push(dep);
               concepts.forEach(function(concept) {
                   if(!self.predicates.hasOwnProperty(concept)) return;;
                   for(let predicateId in self.predicates[concept]) {
                       if(self.nodes[nodeId].law == self.nodes[predicateId].law) continue;
                       self.checkPredicate(nodeId, predicateId);
                   }
               });
            }
            $('#evaluate-msg').text('Done evaluating');
        };

        //see if the relation matches the predicate by recursively tracing the law up to its wildcards
        Relation.prototype.checkPredicate = function(nodeID, predicateID, map) {

            let self = this, nodeId = parseInt(nodeID), predicateId = parseInt(predicateID),
                node = this.nodes[nodeId], predicate = this.nodes[predicateId];

            //if this is the first recursion step, initialize aggregators
            let firstLevel = !map;
            if(firstLevel) {
                map = {lawId: predicate['law'], predicates: [predicateId], idMap: {}, values: {}, intersects: {}, children: []};
            }

            //make sure at least one of this node's associated concepts matches the predicate's concept
            let match = predicate.concept == self.wildcardConcept
                || node.concept == predicate.concept
                || self.concepts[node.concept].dependencies[predicate.concept]
            if(!match && self.concepts[node.concept].inherits && node.head > 0 && self.nodes.hasOwnProperty(node.head)) {
                let headConcept = self.nodes[node.head].concept;
                if(headConcept > 0){
                    match = headConcept == predicate.concept
                            || self.concepts[headConcept].dependencies[predicate.concept];
                }
            }
            //and find the intersection of any values on the two nodes
            let values = null;
            if(match) values = node.values.intersect(predicate.values);
            if(!match || (values && values.length == 0)) return false;

            map.idMap[nodeId] = predicateId;
            map.idMap[predicateId] = nodeId;
            map.values[nodeId] = values;

            //note any prior mappings between this node and predicate node - used later to test for intersections
            if(self.nodeMap.hasOwnProperty(nodeId) && self.nodeMap[nodeId].hasOwnProperty(predicateId)) {
                for(let mapId in self.nodeMap[nodeId][predicateId]) {
                    map.intersects[mapId] = true;
                }
            }

            //for symmetric nodes, make 2 submaps, one for each orientation
            let symmetric = self.concepts[node.concept].symmetric, fwdMap = map, revMap = map, fwd = true, rev = true;
            let nh = node.head, nr = node.reference, ph = predicate.head, pr = predicate.reference, twoMaps = false;
            if(symmetric && ((ph && nh) || (pr && nr))) {
                twoMaps = true;
                fwdMap = {lawId: predicate.law, predicates: [predicateId], idMap: {}, values: {}, intersects: {}, children: [], parent: map};
                revMap = {lawId: predicate.law, predicates: [predicateId], idMap: {}, values: {}, intersects: {}, children: [], parent: map};
            }

            //check recursively on this node's head and reference
            if(ph) fwd = fwd && nh && self.checkPredicate(nh, ph, fwdMap);
            if(pr) fwd = fwd && nr && self.checkPredicate(nr, pr, fwdMap);
            //for symmetric nodes, check the other orientation
            if(symmetric) {
                if(ph) rev = rev && nr && self.checkPredicate(nr, ph, revMap);
                if(pr) rev = rev && nh && self.checkPredicate(nh, pr, revMap);
                //if both succeed, keep the two alternatives as a pair of submaps
                if(fwd && rev) {
                    if(twoMaps) map.children.push([fwdMap, revMap]);
                }
                //if only one, absorb the corresponding submap into this map
                else if(fwd || rev) {
                    let keepMap = fwd ? fwdMap : revMap;
                    if(!self.absorbMap(map, keepMap)) return false;
                }
            } else rev = false;
            //and if neither direction worked, the predicate fails
            if(!fwd && !rev) return false;

            if(firstLevel) {
                //at this point we have a complete match to the predicate
                //separate all the forks on symmetric nodes into full maps
                let maps = self.splitMaps(map), newMaps = 0, law = self.laws[predicate.law];
                console.log('node ' + nodeId + ' matches ' + law.name + ' on ' + predicateId);
                console.log('   ' + maps.length + ' map versions');
                let satisfied = !law.predicateSets.every(function(pset) {
                    return !(pset.length == 1 && pset[0] == predicateId);
                });
                if(satisfied) console.log('   satisfied');
                maps.forEach(function(map) {
                    let count = 0, id = self.nextMapId;
                    for(let n in map.idMap) {
                        let p = map.idMap[n];
                        if(!self.nodeMap.hasOwnProperty(n)) self.nodeMap[n] = {};
                        if(!self.nodeMap[n].hasOwnProperty(p)) self.nodeMap[n][p] = {};
                        if(!self.nodeMap.hasOwnProperty(p)) self.nodeMap[p] = {};
                        if(!self.nodeMap[p].hasOwnProperty(n)) self.nodeMap[p][n] = {};
                        self.nodeMap[n][p][id] = 1;
                        self.nodeMap[p][n][id] = 1;
                        count++;
                    }
                    if(count > 0) {
                        map.id = id;
                        self.map[self.nextMapId++] = map;
                        newMaps++;
                    }
                    if(satisfied) {
                        self.appendLaw(map);
                    } else {
                        for(let other in map.intersects) {
                            self.checkIntersection(map.id, other);
                        }
                    }
                });
            }
            return true;
        };


        Relation.prototype.absorbMap = function(map, submap) {
            let self = this;
            for(let n in submap.idMap) {
                if(map.idMap.hasOwnProperty(n) && map.idMap[n] != submap.idMap[n]) return false;
                map.idMap[n] = submap.idMap[n];
            }
            for(let n in submap.values) map.values[n] = submap.values[n];
            for(let m in submap.intersects) map.intersects[m] = submap.intersects[m];
            map.children = map.children.concat(submap.children);
        };


        Relation.prototype.splitMaps = function(map) {
            let self = this, maps = [];

            map.children.forEach(function(pair) {
                let submaps = self.splitMaps(pair[0]).concat(self.splitMaps(pair[1]));
                submaps.forEach(function(submap) {
                    let merge = self.mergeMaps(map, submap);
                    if(merge) maps.push(merge);
                });
            });

            if(maps.length == 0) maps.push(map);

            return maps;
        }


        Relation.prototype.mergeMaps = function(map1, map2) {
            let self = this, map = {};

            map.lawId = map1.lawId;
            for(let n in map1.idMap) {
                if(map2.idMap.hasOwnProperty(n) && map2.idMap[n] != map1.idMap[n]) return false;
            }
            map.idMap = Object.assign({}, map1.idMap, map2.idMap);
            map.values = Object.assign({}, map1.values, map2.values);
            map.intersects = Object.assign({}, map1.intersects, map2.intersects);
            map.predicates = map1.predicates.concat(map2.predicates);
            map.children = [];

            return map;
        };


        Relation.prototype.checkIntersection = function(mapId1, mapId2) {

            let self = this, map1 = self.map[mapId1], map2 = self.map[mapId2];
            console.log('intersecting map ' + mapId1 + ' with ' + mapId2);

            //make sure the two maps are for the same law, but their predicate sets are disjoint
            if(map1.lawId != map2.lawId) return false;
            let disjoint = map1.predicates.every(function(predicate) {
                    return map2.predicates.indexOf(predicate) < 0;
                });
            if(!disjoint) return false;

            //and that the joint predicate set is part of a set that satisfies the law
            let law = self.laws[map1.lawId], predicateSet = map1.predicates.concat(map2.predicates), match = null;
            let predicates1 = map1.predicates.join(','), predicates2 = map2.predicates.join(',');
            console.log('intersecting ' + predicates1 + ' with ' + predicates2 + ' for ' + law.name);
            console.log('   requires: ' + JSON.stringify(law.predicateSets));
            let cannotCombine = law.predicateSets.every(function(pset) {
                let isSubset = predicateSet.every(function(predicate) {
                    return pset.indexOf(predicate) >= 0;
                }), isMatch = false;
                if(isSubset) {
                    console.log('   subset');
                    //meanwhile, check if the predicates in the two maps in fact satisfy the law
                    isMatch = pset.every(function(predicate) {
                        return predicateSet.indexOf(predicate) >= 0;
                    });
                    if(isMatch) {
                        match = pset;
                        console.log('   match');
                    }
                }
                return !isSubset && !isMatch;
            });
            if(match == null && cannotCombine) {
                console.log('   predicate failure');
                return false;
            }

            //whichever relation nodes are shared by the two maps must be mapped to the same predicate node
            for(let node in map1.idMap) {
                if(!map2.idMap.hasOwnProperty(node)) continue;
                if(map2.idMap[node] != map1.idMap[node]) return false;
            }
            console.log('   success');

            //at this point they do intersect, so create a new map by merging these two
            let map = self.mergeMaps(map1, map2);
            self.map[self.nextMapId++] = map;

            //if the law has been satisfied, use the map to append the knowledge of the law to our relation
            if(match) {
                self.appendLaw(map);
            }

            return true;
        };


        //given a correspondence between nodes in the relation and predicate, fill in the rest of the law
        Relation.prototype.appendLaw = function(map) {

            var self = this;

            //update our relation with all value intersections calculated during the mapping
            for(let node in map.values) {
                self.nodes[node].values = map.values[node];
            }

            //start at each deep node of the law
            var law = self.laws[map.lawId];
            law.deepNodes.forEach(function(nodeId) {
               self.appendLawHelper(map, nodeId);
            });
        };

        Relation.prototype.appendLawHelper = function(map, nodeId) {

            if(map.idMap.hasOwnProperty(nodeId)) return map.idMap[nodeId];

            let self = this, node = self.nodes[nodeId], head = node['head'], reference = node['reference'],
                newHead = self.appendLawHelper(map, head), newReference = self.appendLawHelper(map, reference);

            if(newHead == null || newReference == null) return null;

            for(let child in self.nodes[newHead].children) {
                if(self.nodes[child].concept == node.concept && self.nodes[child].reference == newReference) {
                    return child;
                }
            }
            if(self.concepts[node.concept].symmetric) {
                for(let child in self.nodes[newReference].children) {
                    if(self.nodes[child].concept == node.concept && self.nodes[child].reference == newHead) {
                        return child;
                    }
                }
            }

            let newId = self.addNode({
                'law': self.law.id,
                'concept': node['concept'],
                'head': parseInt(newHead),
                'reference': parseInt(newReference),
                'values': self.nodes[nodeId].values
            });
            self.myNodes.push(newId);
            self.newNodes.push(newId);
            self.nodesToCheck.push(newId);
            map.idMap[nodeId] = newId;
            map.idMap[newId] = nodeId;

            self.drawNode(newId, {
                template: 'appended',
                drawLinks: true
            });
            return newId;
        };


        Relation.prototype.addNode = function(data) {
            let self = this, newId = self.nextNodeId;
            self.nextNodeId++;
            let node = self.nodes[newId] = Object.assign({id: newId, children: {}}, data);
            if(node.head && self.nodes.hasOwnProperty(node.head)) {
                self.nodes[node.head].children[node.id] = true;
            }
            return newId;
        };


        Relation.prototype.selectEntry = function(table, callback, opts) {
            let self = this;
            let options = Object.assign({
                tab: 'search',
                framework: self.framework.id,
                fields: {}
            }, opts);
            let $modal = $('#' + table + '-select'), $form = $modal.find('#' + table + '-create-form');
            $modal.find('#' + table + '-' + options.tab + '-tab').show().tab('show');
            $modal.find('.framework-filter').val(options.framework);
            self.showSearchResults(table, '');
            $modal.data('callback', callback);
            $form.find('input,select').each(function(i, el) {
                let $el = $(el), name = $el.attr('name');
                if(name == 'table') return;
                let value = options.fields[name] || (name == 'framework' ? '-1' : '');
                let $multiple = $el.parents('.multiple-wrapper');
                if($el.is('input[type=checkbox]')) $el.attr('checked', value ? true : false);
                else if($multiple.length > 0) {
                    $multiple.find('.multiple-item').first().nextAll('.multiple-item').remove();
                    if(typeof value == 'object') value.forEach(function(row) {
                        self.addMultipleField($multiple, row);
                    });
                } else $el.val(value);
            });
            $modal.modal('show');
        };


        Relation.prototype.newEntry = function(table, callback) {
            let self = this, $modal = $('#' + table + '-select');
            $modal.find('#' + table + '-search-tab').hide();
            $modal.find('#' + table + '-create-tab').tab('show');
            $modal.find('.framework-filter').val(self.framework.id);
            $modal.data('callback', callback);
            $modal.modal('show');
        };


        Relation.prototype.editEntry = function(table, id, callback) {
            let self = this, entries = self.getTable(table);
            if(!entries.hasOwnProperty(id)) return;
            let entry = entries[id];
            let $modal = $('#' + table + '-edit'), $form = $modal.find('#' + table + '-edit-form');
            $form.find('[name="id"]').val(id);
            $form.find('[name="name"]').val(entry.name);
            $form.find('[name="description"]').val(entry.description);
            $modal.find('.framework-filter').val(entry.framework);
            if(table == 'concept') {
                $form.find('[name="law_specific"]').attr('checked', entry.law > 0);
                $form.find('[name="law"]').val(self.law.id);
                $form.find('[name="symmetric"]').attr('checked', entry.symmetric);
                $form.find('[name="head"]').val(entry.head);
                $form.find('[name="reference"]').val(entry.reference);
            }
            if(table == 'framework' || table == 'concept') {
                let $wrapper = $form.find('.multiple-wrapper');
                $wrapper.find('.multiple-item').first().nextAll('.multiple-item').remove();
                let depCount = 0;
                for(let dep in entry.dependencies) {
                    self.addMultipleField($wrapper, {dependencies: dep});
                    depCount++;
                }
                if(depCount == 0) self.addMultipleField($wrapper);
            }
            $modal.data('callback', callback);
            $modal.modal('show');
        }


        Relation.prototype.addMultipleField = function($element, values) {
            let self = this, $template = $element.find('.multiple-template');
            //add a new copy of the template
            let $entry = $template.clone().removeClass('multiple-template');
            //update any input field choices according to the current data set
            self.updateFields($entry);
            //update the index, and values if given, on all sub-elements that have names for form submission
            $element.find('.multiple-item').last().after($entry);
            let index = $entry.index();
            $entry.find('[name]').each(function() {
                let $this = $(this), name = $this.attr('name');
                $this.attr('name', name + '_' + index);
                if(typeof values == 'object' && values.hasOwnProperty(name)) $this.val(values[name]);
            });
            //add listener to the REMOVE button
            let $required = $entry.find('.multiple-required'), $removeButton = $entry.find('.multiple-remove');
            $removeButton.click(function(e) {
                if($(this).hasClass('disabled')) return;
                $entry.remove();
            });
        };


        Relation.prototype.showSearchResults = function(table, text) {
            let self = this;

            let entries = self.getTable(table), results = [];
            if(!entries) return;

            let $tab = $('#' + table + '-search-tab-content'), $results = $tab.find('#' + table + '-results'),
                $framework = $tab.find('.framework-filter');
            let framework = $framework.val();

            for(let i in entries) {
                let id = i, entry = entries[id];
                if(framework > 0 && entry.framework != framework) continue;
                if(entry.hasOwnProperty('name')) {
                    let name = entry.name.toLowerCase();
                    if(name.indexOf(text) >= 0) {
                        let result =
                            '<div id="' + table + '-result-' + id + '" class="result-display">' +
                            '<span class="result-name">' + entry.name + '</span>';
                        if(entry.hasOwnProperty('description'))
                            result += '<span class="result-description">' + entry.description + '</span>';
                        result += '</div>';
                        let $result = $(result);
                        $result.click(function(e) {
                            $('#' + table + '-selected-id').val(id);
                            $results.children().removeClass('selected');
                            $(this).addClass('selected');
                        });
                        results.push($result);
                    }
                }
            }
            $results.empty();
            results.forEach(function($res) { $results.append($res); });
        };


        Relation.prototype.visualize = function() {
            let self = this, canvas = self.canvas;
            self.syncGraph();

            canvas.strokeColor = 'red';
            canvas.lineWidth = 4;
            canvas.fillColor = 'blue';

            //all the visualization objects will have been determined in the relation
            let objects = self.law.getNodesByConcept('visual');
            objects.forEach(function(object) {
                let shapes = object.getChildrenByConcept('shape');
                shapes.forEach(function(shape) {
                    let shapeName = shape.getConcept().name, opt = self.getChildTree(shape);
                    console.log('drawing shape ' + shapeName);
                    console.info(opt);
                    switch(shapeName) {
                        case 'line':
                            let x1 = null, y1 = null, x2 = null, y2 = null;
                            if(opt.start && opt.start._value) {
                                x1 = opt.start._value.values[0];
                                y1 = opt.start._value.values[1];
                            }
                            if(opt.end && opt.end._value) {
                                x2 = opt.end._value.values[0];
                                y2 = opt.end._value.values[1];
                            }
                            if(typeof x1 == 'number' && typeof x2 == 'number' && typeof y1 == 'number' && typeof y2 == 'number') {
                                canvas.beginPath();
                                canvas.moveTo(x1, y1);
                                canvas.lineTo(x2, y2);
                                canvas.stroke();
                            }
                            break;
                        case 'arrow':
                            break;
                        case 'arc':
                            break;
                        case 'circle':
                            break;
                        case 'triangle':
                            break;
                        case 'rectangle':
                            break;
                        default: break;
                    }
                });
            });
        };


        Relation.prototype.getChildTree = function(node) {
            let self = this, opts = {_value: node.getValue()};
            let children = node.getChildren();
            children.forEach(function(child) {
                let concept = child.getConcept();
                opts[concept.name] = self.getChildTree(child);
            });
            return opts;
        };


        var relation;
        $(document).ready(function() {
            relation = new Relation();
            let self = relation;

            self.initDiagram();
            self.setLaw(-1);
            self.useFramework(-1);

            let $hideButton = null;
            $('.entry-modal button[data-dismiss=modal]').click(function(e) {
                $hideButton = $(this);
            });
            $('.entry-modal').on('show.bs.modal', function(e) {
                $hideButton = null;
            });
            $('.entry-modal').on('hide.bs.modal', function(e) {

                let $this = $(this), $button = $hideButton || $(document.activeElement), callback = $this.data('callback');
                let prefix = $this.attr('id'), prefixArr = prefix.split('-'), table = prefixArr[0], type = prefixArr[1];
                console.log('modal ' + $this.attr('id') + ' hidden');

                if($button.hasClass('modal-cancel')) {
                    return;

                } else if($button.hasClass('modal-select')) {
                    let id = $('#' + table + '-selected-id').val();
                    if(!id) return;
                    if(callback) callback.call(self, id);

                } else if($button.hasClass('modal-save')) {
                    let $form = $this.find('form.entry-form'), arr = $form.serializeArray(), obj = {};
                    for(let i = 0; i < arr.length; i++) obj[arr[i]['name']] = arr[i]['value'];

                    //convert any multiple fields to proper format
                    $form.find('.multiple-template').each(function() {
                        let $this = $(this), $fields = $this.find('[name]');
                        $fields.each(function() {
                            let name = $(this).attr('name');
                            obj[name] = {};
                            for(let key in obj) if(key.startsWith(name + '_')) {
                                obj[name][obj[key]] = true;
                                delete obj[key];
                            }
                        });
                    });

                    if(table == 'framework') {
                        for(let dep in obj.dependencies) {
                            let framework = self.findEntry('framework', dep);
                            //when saving a framework, flag dependency frameworks that need to be loaded
                            //so the server can send them
                            obj.dependencies[dep] = framework && !framework.loaded;
                        }
                    }

                    console.log('saving entry');
                    console.info(obj);
                    $.ajax({
                        url: "{{=URL('default', 'saveEntry', extension='json')}}",
                        type: 'post',
                        dataType: 'json',
                        data: JSON.stringify(obj),
                        success: function(data) {
                            if(data.hasOwnProperty('id') && !isNaN(data.id)) {
                                self.storeEntries(data);
                                if(callback) callback.call(self, data.id);
                            }
                        }
                    });
                }
            });

            let $filters = $('.framework-filter');
            $filters.change(function(e) {
                let $this = $(this), framework = $this.val(), $modal = $(this).parents('.modal');
                if($modal.length > 0) {
                    let table = $modal.attr('id').split('-')[0];
                    $modal.find('.framework-filter').val(framework);
                    let type = $modal.attr('id').split('-')[1];
                    if(type == 'select') self.showSearchResults(table, '');
                } else if($this.attr('id') == 'palette-concept-filter') {
                    self.filterPalette(framework);
                }
            });

            $('.entry-wrapper').each(function() {
                let $this = $(this), table = $this.attr('table');
                $this.find('.entry-set-button').click(function(e) {
                    self.selectEntry(table, function(id) {
                        if(table == 'framework') self.useFramework(id);
                        else if(table == 'law') self.useLaw(id);
                        let entry = self.findEntry(table, id);
                        $this.find('.entry-name').text(entry.name || 'None');
                        $this.find('.entry-info').show();
                    });
                });
                $this.find('.entry-edit-button').click(function(e) {
                    let id = table == 'framework' ? self.framework.id : table == 'law' ? self.law.id : null;
                    if(!id) return;
                    self.editEntry(table, id);
                });
            });

            $('#concept-create-button').click(function(e) {
                self.newEntry('concept');
            });

            $('.search-field').on('keydown change', function(e) {
                let $this = $(this), text = $this.val().toLowerCase(), table = $this.attr('id').split('-')[0];
                self.showSearchResults(table, text);
            });

            $('.multiple-wrapper').each(function() {
                let $this = $(this);
                self.addMultipleField($this);
                $this.find('.multiple-add').click(function(e) {
                    self.addMultipleField($this);
                });
            });


            $('#set-predicate').change(function(e) {
                relation.setPredicate($(this).val());
            });
            $('#remove-predicate').click(function(e) {
                relation.removePredicate();
            });

            $('#save-relation').click(function(e) {
                relation.save();
            });
            $('#evaluate-relation').click(function(e) {
                relation.evaluate();
            });
            $('#visualize-relation').click(function(e) {
                relation.visualize();
            })
        });

    </script>
    {{end page_js}}

</html>